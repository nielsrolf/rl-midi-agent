"""
Data generators for training and validation data
"""
import numpy as np
from random import shuffle
from musicrl.random_generator import resemble_midi
from musicrl.render import midi2mel


REAL = 1
GEN = 0


class RandomMidiDataGenerator():
    """
    Take some real data and build a generator that can be used to train
    a discriminator on real data and ranom midi data generated by 
    and create a data_generator for training or testing.
    When creating batches, it cuts sequences to the shortest length of the batch.
    We could also pad it to the longest sequence, but it doesn't matter at this point.
    Gets:
        real_midis: List[pretty_midi.PrettyMidi]
        preprocess: (pretty_midi.PrettyMidi) -> model input
        mapper: midi2vec.MidiVectorMapper which shall be used by resemble_midi
        batch_size: int
        max_num_timeframes: each batch is cut to at most this many timeframes. This can avoid memory issues,
            which result in an error like this
            `[1]    2097 bus error  /Users/nielswarncke/opt/anaconda3/envs/midi-rl/bin/python  --default --client`
    """
    def __init__(self, real_midis, preprocess, mapper, batch_size, max_num_timeframes=8000):
        self.real_midis = real_midis
        self.preprocess = preprocess
        self.batch_size = batch_size
        self.mapper = mapper
        self.max_num_timeframes = max_num_timeframes
        self.idx = 0
        self.epochs = 0
        self.steps_per_epoch = len(self.real_midis)//(batch_size//2)

    def __call__(self):
        while True:
            if self.idx + self.batch_size//2 >= len(self.real_midis):
                self.idx = 0
                shuffle(self.real_midis)
                self.epochs += 1
            real_midis = self.real_midis[self.idx:self.idx+self.batch_size//2]
            real_preprocessed = [self.preprocess(midi) for midi in real_midis]
            fake_preprocessed = [self.preprocess(self.mapper.vec2midi(resemble_midi(midi, self.mapper))) for midi in real_midis]
            min_length = min([mel.shape[0] for mel in real_preprocessed+fake_preprocessed])
            min_length = min(min_length, self.max_num_timeframes)
            x = [mel[:min_length] for mel in real_preprocessed+fake_preprocessed]
            y = np.array([REAL]*(self.batch_size//2) + [GEN]*(self.batch_size//2)).reshape((-1, 1))
            self.idx += self.batch_size
            yield np.array(x), y

            